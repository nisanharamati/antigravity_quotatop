#!/usr/bin/env python3
import curses
from enum import StrEnum
import json
import platform
import re
import ssl
import subprocess
import sys
import time
from datetime import datetime, timezone
from http.client import HTTPSConnection, HTTPConnection
import socket


def run_cmd(cmd):
    result = subprocess.run(
        cmd,
        shell=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        encoding="utf-8",
    )
    return result.stdout, result.stderr, result.returncode


USE_COLOR = sys.stdout.isatty()
class Color(StrEnum):
    COLOR_RESET = "\033[0m"
    COLOR_DIM = "\033[2m"
    COLOR_BOLD = "\033[1m"
    COLOR_GREEN = "\033[32m"
    COLOR_YELLOW = "\033[33m"
    COLOR_RED = "\033[31m"
    COLOR_CYAN = "\033[36m"


def is_antigravity_process(cmdline):
    if re.search(r"--app_data_dir\s+antigravity\b", cmdline, re.I):
        return True
    lower = cmdline.lower()
    return ("\\antigravity\\" in lower) or ("/antigravity/" in lower)


def get_process_info_linux():
    process_name = (
        "language_server_linux_arm" if platform.machine() == "arm64" else
        "language_server_linux_x64"
    )
    cmd = f"pgrep -af {process_name}"
    stdout, stderr, code = run_cmd(cmd)
    for line in stdout.splitlines():
        if "--extension_server_port" in line:
            parts = line.strip().split()
            pid = int(parts[0])
            cmdline = line[len(parts[0]):].strip()
            port_match = re.search(r"--extension_server_port[=\s]+(\d+)", cmdline)
            token_match = re.search(r"--csrf_token[=\s]+([a-zA-Z0-9\-]+)", cmdline)
            return {
                "pid": pid,
                "extension_port": int(port_match.group(1)) if port_match else 0,
                "csrf_token": token_match.group(1) if token_match else "",
            }
    return None

def get_process_info_macos():
    process_name = (
        'language_server_macos_arm' if platform.machine() == "arm64" else
        'language_server_macos_x64'
    )
    cmd = f"ps -ax -o pid -o command"
    stdout, stderr, code = run_cmd(cmd) # TODO: fix this to return non mal-encoded strings
    for line in stdout.splitlines():
        if process_name in line and "--extension_server_port" in line:
            parts = line.strip().split()
            pid = int(parts[0])
            cmdline = line[len(parts[0]):].strip()
            port_match = re.search(r"--extension_server_port[=\s]+(\d+)", cmdline)
            token_match = re.search(r"--csrf_token[=\s]+([a-zA-Z0-9\-]+)", cmdline)
            foo={
                "pid": pid,
                "extension_port": int(port_match.group(1)) if port_match else 0,
                "csrf_token": token_match.group(1) if token_match else "",
            }
            return foo
    return None

def get_listening_ports_unix(pid):
    ports = set()

    ss_cmd = f"ss -tlnp 2>/dev/null | grep \"pid={pid}\""
    stdout, stderr, code = run_cmd(ss_cmd)
    ss_regex = re.compile(r"LISTEN\s+\d+\s+\d+\s+(?:\*|[\d.]+|\[[\da-f:]*\]):(\d+).*?pid=%d" % pid, re.I)
    for m in ss_regex.finditer(stdout):
        ports.add(int(m.group(1)))

    if not ports:
        lsof_cmd = f"lsof -nP -a -iTCP -sTCP:LISTEN -p {pid} 2>/dev/null"
        stdout, stderr, code = run_cmd(lsof_cmd)
        lsof_regex = re.compile(r"^\S+\s+%d\s+.*?(?:TCP|UDP)\s+(?:\*|[\d.]+|\[[\da-f:]+\]):(\d+)\s+\(LISTEN\)" % pid, re.I | re.M)
        for m in lsof_regex.finditer(stdout):
            ports.add(int(m.group(1)))

    return sorted(ports)


def parse_os_release():
    data = {}
    try:
        with open("/etc/os-release", "r", encoding="utf-8") as handle:
            for line in handle:
                line = line.strip()
                if not line or line.startswith("#") or "=" not in line:
                    continue
                key, value = line.split("=", 1)
                data[key] = value.strip().strip('"')
    except OSError:
        return {}
    return data


def is_supported_distro():
    if sys.platform == 'darwin':
        return True
    if sys.platform != "linux":
        return False
    os_release = parse_os_release()
    distro_id = os_release.get("ID", "").lower()
    id_like = os_release.get("ID_LIKE", "").lower()
    if distro_id in {"debian", "kali"}:
        return True
    return "debian" in id_like.split()


def request_json(port, path, token, body, use_https=True):
    data = json.dumps(body).encode("utf-8")
    headers = {
        "Content-Type": "application/json",
        "Content-Length": str(len(data)),
        "Connect-Protocol-Version": "1",
        "X-Codeium-Csrf-Token": token,
    }

    if use_https:
        context = ssl.create_default_context()
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE
        conn = HTTPSConnection("127.0.0.1", port, context=context, timeout=5)
    else:
        conn = HTTPConnection("127.0.0.1", port, timeout=5)

    try:
        conn.request("POST", path, body=data, headers=headers)
        resp = conn.getresponse()
        resp_body = resp.read().decode("utf-8", errors="replace")
        return resp.status, resp_body
    finally:
        conn.close()


def find_working_port(ports, token):
    for port in ports:
        for use_https in (True, False):
            try:
                status, body = request_json(
                    port,
                    "/exa.language_server_pb.LanguageServerService/GetUnleashData",
                    token,
                    {"wrapper_data": {}},
                    use_https=use_https,
                )
            except (ssl.SSLError, OSError, socket.error):
                continue
            if status == 200:
                try:
                    json.loads(body)
                    return port, use_https
                except Exception:
                    pass
    return None, None


def format_duration(delta):
    total_seconds = int(delta.total_seconds())
    if total_seconds <= 0:
        return "Ready"
    mins = total_seconds // 60
    hours = mins // 60
    days = hours // 24
    mins = mins % 60
    hours = hours % 24
    parts = []
    if days:
        parts.append(f"{days}d")
    if hours:
        parts.append(f"{hours}h")
    if mins or not parts:
        parts.append(f"{mins}m")
    return " ".join(parts)


def parse_reset_time(reset_time):
    if not reset_time:
        return None
    try:
        if reset_time.endswith("Z"):
            reset_time = reset_time[:-1] + "+00:00"
        return datetime.fromisoformat(reset_time)
    except ValueError:
        return None


def get_quota_summary(data):
    lines = []
    user = data.get("userStatus", {})
    plan_status = user.get("planStatus", {})
    plan_info = plan_status.get("planInfo", {})

    plan_name = plan_info.get("planName", "Unknown")
    tier = plan_info.get("teamsTier", "Unknown")
    prompt_available = plan_status.get("availablePromptCredits")
    flow_available = plan_status.get("availableFlowCredits")

    lines.append((Color.COLOR_BOLD, f"Plan:"))
    lines.append((None, f" {plan_name} ({tier})"))
    lines.append((None, "\n"))
    if prompt_available is not None:
        lines.append((Color.COLOR_CYAN, f"Prompt credits available:"))
        lines.append((None, f" {prompt_available}"))
        lines.append((None, "\n"))
    if flow_available is not None:
        lines.append((Color.COLOR_CYAN, f"Flow credits available:"))
        lines.append((None, f" {flow_available}"))
        lines.append((None, "\n"))

    models = user.get("cascadeModelConfigData", {}).get("clientModelConfigs", [])
    rows = []
    for model in models:
        quota = model.get("quotaInfo") or {}
        remaining_fraction = quota.get("remainingFraction")
        if not quota and remaining_fraction is None:
            continue
        elif remaining_fraction is None:
            remaining_fraction = 0
        label = model.get("label", "Unknown")
        model_id = (model.get("modelOrAlias") or {}).get("model", "unknown")
        reset_time = parse_reset_time(quota.get("resetTime"))
        if reset_time is not None:
            now = datetime.now(timezone.utc)
            delta = reset_time - now
            reset_desc = f"{format_duration(delta)} ({reset_time.astimezone(timezone.utc).strftime('%Y-%m-%d %H:%M UTC')})"
        else:
            reset_desc = "Unknown"
        rows.append((label, model_id, remaining_fraction * 100.0, reset_desc))

    if not rows:
        return "No model quota info found."

    rows.sort(key=lambda r: r[0].lower())
    label_w = max(len("Model"), max(len(r[0]) for r in rows))
    id_w = max(len("Model ID"), max(len(r[1]) for r in rows))
    lines.append((None, "\n"))
    lines.append((Color.COLOR_BOLD, f"{'Model':<{label_w}}  {'Model ID':<{id_w}}  {'Remaining':>9}  Reset"))
    lines.append((None, "\n"))
    lines.append((Color.COLOR_DIM, f"{'-' * label_w}  {'-' * id_w}  {'-' * 9}  {'-' * 5}"))
    lines.append((None, "\n"))
    for label, model_id, remaining_pct, reset_desc in rows:
        if remaining_pct <= 0:
            color = Color.COLOR_RED
        elif remaining_pct < 20:
            color = Color.COLOR_YELLOW
        else:
            color = Color.COLOR_GREEN
        lines.append((None, f"{label:<{label_w}}  {model_id:<{id_w}}  "))
        lines.append((color, f"{remaining_pct:>8.1f}%"))
        lines.append((Color.COLOR_DIM, f"  {reset_desc}"))
        lines.append((None, "\n"))

    return lines

def main(in_loop=False):
    if not is_supported_distro():
        print("Unsupported OS: this script only supports Debian and Kali Linux.")
        sys.exit(1)

    info = (get_process_info_linux() if sys.platform == 'linux' else get_process_info_macos())

    if not info:
        print("Could not find language_server process or csrf token.")
        sys.exit(1)

    token = info.get("csrf_token", "")
    if not token:
        print("No CSRF token found in process command line.")
        sys.exit(1)

    ports = get_listening_ports_unix(info["pid"])

    if not ports:
        print("No listening ports found for the language_server process.")
        sys.exit(1)

    port, use_https = find_working_port(ports, token)
    if not port:
        print("No working port responded to GetUnleashData.")
        sys.exit(1)

    status, body = request_json(
        port,
        "/exa.language_server_pb.LanguageServerService/GetUserStatus",
        token,
        {"metadata": {"ideName": "antigravity", "extensionName": "antigravity", "locale": "en"}},
        use_https=use_https,
    )

    if status != 200:
        print(f"GetUserStatus failed: HTTP {status}")
        print(body)
        sys.exit(1)

    try:
        data = json.loads(body)
        if in_loop is False:
            for color, chunk in get_quota_summary(data):
                try:
                    if color is not None:
                        print(f"{color.value}{chunk}", end="")
                    else:
                        print(f"{Color.COLOR_RESET.value}{chunk}", end="")
                except Exception as ex:
                    print("failed on chunk", chunk)
                    print(ex)
                    raise ex
            print()
        else:
            return get_quota_summary(data)
    except Exception as ex:
        print("Invalid JSON response:")
        print(body)
        print()
        raise ex

LOOP_DELAY = 60
def print_loop(stdscr):
    # Initialize curses settings
    curses.start_color()
    curses.use_default_colors()
    curses.curs_set(0) # Make the cursor invisible
    stdscr.nodelay(1)  # Don't wait for user input (non-blocking getch())
    curses.noecho()    # Turn off automatic echoing of keys to the screen
    curses.cbreak()    # Enter cbreak mode (disable line buffering)
    stdscr.keypad(1)   # Enable special key values like curses.KEY_LEFT

    # WHITE = 1
    curses.init_pair(1, curses.COLOR_WHITE, -1)
    # GREEN = 2
    curses.init_pair(2, curses.COLOR_GREEN, -1)
    # YELLOW = 3
    curses.init_pair(3, curses.COLOR_YELLOW, -1)
    # RED = 4
    curses.init_pair(4, curses.COLOR_RED, -1)
    # CYAN = 5
    curses.init_pair(5, curses.COLOR_CYAN, -1)

    title_line = "="*108
    title_str = "{:<54}".format("ANTIGRAVITY QUOTA TOP")

    try:
        while True:
            stdscr.clear()
            t0 = time.time()
            chunks = main(in_loop=True)
            stdscr.addstr(title_line)
            stdscr.addstr("\n")
            stdscr.addstr(title_str + "{:>54}".format(str(datetime.now())))
            stdscr.addstr("\n")
            stdscr.addstr(title_line)
            stdscr.addstr("\n")
            for color, chunk in chunks:
                match color:
                    case Color.COLOR_DIM:
                        ccolor = curses.A_DIM
                    case Color.COLOR_BOLD:
                        ccolor = curses.A_BOLD
                    case Color.COLOR_GREEN:
                        ccolor = curses.color_pair(2)
                    case Color.COLOR_YELLOW:
                        ccolor = curses.color_pair(3)
                    case Color.COLOR_RED:
                        ccolor = curses.color_pair(4)
                    case Color.COLOR_CYAN:
                        ccolor = curses.color_pair(5)
                    case Color.COLOR_RESET:
                        ccolor = None
                    case None:
                        ccolor = None
                    case _:
                        ccolor = None
                if ccolor is not None:
                    stdscr.addstr(chunk, ccolor)
                else:
                    stdscr.addstr(chunk)
            stdscr.addstr("")
            dt = time.time() - t0
            sleep_dt = max(LOOP_DELAY - dt, 0)
            stdscr.refresh()
            time.sleep(sleep_dt)
    except KeyboardInterrupt:
        raise KeyboardInterrupt
    except:
        raise


HELP_TEXT = """
levitycheck.py [-l/--loop delay_seconds]
"""
if __name__ == "__main__":
    if len(sys.argv) > 1:
        if sys.argv[1] in ('-l', '-loop'):
            if len(sys.argv) > 2:
                try:
                    LOOP_DELAY = int(sys.argv[2])
                except ValueError as er:
                    print(f"Couldn't parse loop delay argument. Command args were: {sys.argv}\n\n{HELP_TEXT}")
                    sys.exit(1)
            try:
                curses.wrapper(print_loop)()
            except KeyboardInterrupt:
                sys.exit(0)
        print(f"Unknown commandline args: {sys.argv}\n\n{HELP_TEXT}")
    else:
        main()
